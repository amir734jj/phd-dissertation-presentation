\section{Implementation}


\begin{frame}[fragile=singleslide]{APS Code Generation}{Desired Scala code generation final result: Scala Traits}


\begin{Verbatim}[fontsize=\tiny]
val t_IntegerMaxLattice = new M_MAX_LATTICE[T_Integer]
        ("IntegerMaxLattice",t_Integer,0)
    with C_TYPE[T_Integer]
    with C_PRINTABLE[T_Integer]
    with C_ORDERED[T_Integer]
    with C_NUMERIC[T_Integer] {
        override val v_string = t_Integer.v_string;
        override val v_zero = t_Integer.v_zero;
        override val v_one = t_Integer.v_one;
        override val v_plus = t_Integer.v_plus;
        override val v_minus = t_Integer.v_minus;
        override val v_times = t_Integer.v_times;
        override val v_divide = t_Integer.v_divide;
        override val v_unary_plus = t_Integer.v_unary_plus;
        override val v_unary_minus = t_Integer.v_unary_minus;
        override val v_unary_times = t_Integer.v_unary_times;
        override val v_unary_divide = t_Integer.v_unary_divide;
        
        val v_assert = t_Integer.v_assert;
        val v_equal = t_Integer.v_equal;
        val v_node_equivalent = t_Integer.v_node_equivalent;
  }
\end{Verbatim}

\end{frame}

\note[itemize]{
\item APS has a module that generates code in C++ and Scala but it was written as a proof of concept and it had some issues.
\item More specifically, to show the implementation of circular remote attribute grammar working for First and Follow, we need to use lattices in APS
\item But in APS lattices are defined as modules with generic parameters and the module itself extends its own generic parameter
\item Scala does not support this feature so this resulted in generating a Scala code that does not type check
\item So we had to think out of the box and used Scala traits as a way to accomplish this
}



\begin{frame}[fragile=singleslide]{APS Code Generation}{Metadata for AST nodes}

Previously:

\begin{itemize}
    \item Internally, APS \emph{types} are AST nodes. Any replacement of formals with actuals will result in AST creation/modification in the semantic analyzer (outside of the parser). \alert{Anti-pattern}.
    \item No way to \emph{calculate} type of \emph{use}.
\end{itemize}

Now:

\begin{itemize}
    \item \alert{Canonical Type} map a \emph{use} to its type-declaration statement
    \item \alert{Canonical Signatures} map a \alert{Canonical Type} to list of modules with type parameter \alert{substituted} (formals replaced with actuals)
\end{itemize}

\end{frame}

\note[itemize]{
\item Fixing code generation turned out to be tricky because internally APS types are AST nodes
\item Creating AST nodes outside of the parser is anti-pattern
\item So we introduced a concept of canonical types and signatures that substitute formals with actuals and used it in fixing the code generation.
}



\begin{frame}{Canonical Types}{Validation of work have been done so far}
    
After implementing canonical types and signatures into APS, Scala code generated First and Follow examples \alert{now type checks}!

\newlinevspace

$\to$ Next step is getting new \alert{static scheduler} to work so it can take advantage of improvements in code generation.

\end{frame}

\note[itemize]{
\item Canonical types and signatures were successful because Scala code now for First and Follow now type checks.
}