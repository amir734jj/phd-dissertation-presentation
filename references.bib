@inproceedings{riouak2021precise,
  title={A Precise Framework for Source-Level Control-Flow Analysis},
  author={Riouak, Idriss and Reichenbach, Christoph and Hedin, G{\"o}rel and Fors, Niklas},
  booktitle={21st IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM},
  year={2021}
}

@inproceedings{schone2020connecting,
  title={Connecting conceptual models using relational reference attribute grammars},
  author={Sch{\"o}ne, Ren{\'e} and Mey, Johannes and Ebert, Sebastian and A{\ss}mann, Uwe},
  booktitle={Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings},
  pages={1--11},
  year={2020}
}

@article{habibisharif,
  title={Sharif-TaaWS: A tool to generate Test as a Web Service (TaaWS) Through a Method-Based Attribute Grammar},
  author={Habibi, Elahe and Mirian-Hosseinabadi, Seyed-Hasan}
}

@INPROCEEDINGS{Knuth68semanticsof,
    author = {Donald E. Knuth},
    title = {Semantics of Context-Free Languages},
    booktitle = {In Mathematical Systems Theory},
    year = {1968},
    pages = {127--145}
}

@inproceedings{10.1007/978-3-642-25324-9_25,
author = {Hafiz, Rahmatullah and Frost, Richard A.},
title = {Modular Natural Language Processing Using Declarative Attribute Grammars},
year = {2011},
isbn = {9783642253232},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-25324-9_25},
doi = {10.1007/978-3-642-25324-9_25},
abstract = {A system based on a general top-down parsing algorithm has been developed which allows
language processors to be created as executable specifications of arbitrary attribute
grammars. Declarative notation of attribute grammars allows modular construction of
executable language definitions. Syntax is defined through general context-free grammar
rules, and meaning is defined by associated semantic rules with arbitrary dependencies.
An innovative technique allows parses to be pruned by arbitrary semantic constraints.
This new technique is useful in modelling natural-language phenomena by imposing unification-like
restrictions, and accommodating long-distance and cross-serial dependencies, which
cannot be handled by context-free rules alone.},
booktitle = {Proceedings of the 10th Mexican International Conference on Advances in Artificial Intelligence - Volume Part I},
pages = {291–304},
numpages = {14},
keywords = {lazy evaluation, top-down parsing, attribute grammars, compositional semantics, constraint-based formalism},
location = {Puebla, Mexico},
series = {MICAI'11}
}

@MISC{Boyland05remoteattribute,
    author = {John Tang Boyland},
    title = {Remote Attribute Grammars},
    year = {2005}
}

@article{10.1007/BF00288644,
author = {Kastens, Uwe},
title = {Ordered Attributed Grammars},
year = {1980},
issue_date = {March     1980},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {13},
number = {3},
issn = {0001-5903},
url = {https://doi.org/10.1007/BF00288644},
doi = {10.1007/BF00288644},
abstract = {Ordered attributed grammars are defined as a large subclass of semantically well-defined attributed grammars proposed by Knuth. An attributed grammar is ordered if for each symbol a partial order over the associated attributes can be given, such that in any context of the symbol the attributes are evaluable in an order which includes that partial order. The definition does not refer to a predefined strategy for attribute evaluation, e.g. several passes from left to right. For each attributed grammar evaluable by any predefined evaluation strategy such an order exists. The ordering property can be checked by an algorithm, which depends polynomially in time on the size of the input grammar. "Visit-sequences" are computed from the attribute dependencies given by an ordered attributed grammar. They describe the control flow of an algorithm for attribute evaluation which can be part of an automatically generated compiler.},
journal = {Acta Inf.},
month = mar,
pages = {229–256},
numpages = {28}
}

@article{10.1145/13310.13320,
author = {Farrow, Rodney},
title = {Automatic Generation of Fixed-Point-Finding Evaluators for Circular, but Well-Defined, Attribute Grammars},
year = {1986},
issue_date = {July 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/13310.13320},
doi = {10.1145/13310.13320},
abstract = {In the traditional formulation of attribute grammars (AGs) circularities are not allowed, that is, no attribute-instance in any derivation tree may be defined in terms of itself. Elsewhere in mathematics and computing, though, circular (or recursive) definitions are commonplace, and even essential. Given appropriate constraints, recursive definitions are well-founded, and the least fixed-points they denote are computable. This is also the case for circular AGs.This paper presents constraints on individual attributes and semantic functions of an AG that are sufficient to guarantee that a circular AG specifies a well-defined translation and that circularly-defined attribute-instances can be computed via successive approximation. AGs that satisfy these constraints are called finitely recursive.An attribute evaluation paradigm is presented that incorporates successive approximation to evaluate circular attribute-instances, along with an algorithm to automatically construct such an evaluator. The attribute evaluators so produced are static in the sense that the order of evaluation at each production-instance in the derivation-tree is determined at the time that each translator is generated.A final algorithm is presented that tells which individual attributes and functions must satisfy the constraints.},
journal = {SIGPLAN Not.},
month = jul,
pages = {85–98},
numpages = {14}
}

@article{DBLP:journals/informaticaSI/Hedin00,
  author    = {G{\"{o}}rel Hedin},
  title     = {Reference Attributed Grammars},
  journal   = {Informatica (Slovenia)},
  volume    = {24},
  number    = {3},
  year      = {2000},
  timestamp = {Mon, 15 Feb 2016 15:01:43 +0100},
  biburl    = {https://dblp.org/rec/journals/informaticaSI/Hedin00.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{10.1016/j.scico.2005.06.005,
author = {Magnusson, Eva and Hedin, G\"{o}rel},
title = {Circular Reference Attributed Grammars — Their Evaluation and Applications},
year = {2007},
issue_date = {August, 2007},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {68},
number = {1},
issn = {0167-6423},
url = {https://doi.org/10.1016/j.scico.2005.06.005},
doi = {10.1016/j.scico.2005.06.005},
abstract = {This paper presents a combination of Reference Attributed Grammars (RAGs) and Circular Attribute Grammars (CAGs). While RAGs allow the direct and easy specification of nonlocally dependent information, CAGs allow iterative fixed-point computations to be expressed directly using recursive (circular) equations. We demonstrate how the combined formalism, Circular Reference Attributed Grammars (CRAGs), can take advantage of both these strengths, making it possible to express solutions to many problems in an easy way. We exemplify with the specification and computation of the nullable, first, and follow sets used in parser construction, a problem which is highly recursive and normally programmed by hand using an iterative algorithm. We also present a general demand-driven evaluation algorithm for CRAGs and some optimizations of it. The approach has been implemented and experimental results include computations on a series of grammars including that of Java 1.2. We also revisit some of the classical examples of CAGs and show how their solutions are facilitated by CRAGs.},
journal = {Sci. Comput. Program.},
month = aug,
pages = {21–37},
numpages = {17},
keywords = {Grammar flow, Fixed-point evaluation, Demand-driven evaluation, Reference attributes, Live analysis, Circular attribute evaluation, Attribute grammars}
}

@phdthesis{10.5555/924544,
author = {Boyland, John Tang and Graham, Susan L.},
title = {Descriptional Composition of Compiler Components},
year = {1996},
isbn = {0591319284},
publisher = {University of California, Berkeley},
abstract = {New machine architectures and new programming languages are always appearing, and thus the need for new compilers continues unabated. Even experimental languages and machines need compilers. Compiler writers developing new and/or experimental compilers face competing pressures when designing their large-scale structure. On the one hand, a more modular structure will make it easier to maintain, modify or reuse pieces of the compiler. A more modular compiler is more likely to be correct, and reusable compiler components lead to consistent semantics among the compilers using them. On the other hand, a highly modular structure may lead to inefficiencies in implementation. Suppose one uses an intermediate representation and divides up the compiler into two parts, one which compiles the source to the intermediate representation and another which translates a program in the intermediate representation to the target machine language. Doing so may make the compiler easier to understand, and furthermore, a well-chosen intermediate representation may prove a suitable target for other source languages, or a suitable source for translating to other machines. On the other hand, the need to create and then traverse this intermediate representation may slow a compiler significantly. If the two parts are described in a high-level declarative formalism, descriptional composition can be used to combine the two parts automatically so as to avoid creating and traversing the intermediate structure.This dissertation presents a declarative compiler description language, APS, and a new method for descriptional composition. The language, based on a variant of attribute grammars, contains a number of features that aid compiler writers in factoring descriptions so that each concept can be expressed separately. Both a compiler for Oberon2 and a front-end for APS itself have been written in APS. The back-end of the Oberon2 compiler consists of a translation to a form of the "GCC tree" intermediate representation. Another module gives the translation from this form to source-level C text.A prototype compiler has been developed for APS that supports descriptional composition. The descriptionally composed version of the Oberon2 back-end with the translation to C text is no larger than the sum of the sizes of the modules from which it is composed, yet it runs almost twice as fast. The Oberon2 compiler is the first successful use of descriptional composition for a realistically complex system, and demonstrates the effectiveness of combining the new APS description language and the new algorithm for descriptional composition presented in this dissertation.},
note = {AAI9722877}
}

@article{DBLP:journals/entcs/HedinM01,
  author    = {G{\"{o}}rel Hedin and
               Eva Magnusson},
  title     = {JastAdd - a Java-based system for implementing front ends},
  journal   = {Electron. Notes Theor. Comput. Sci.},
  volume    = {44},
  number    = {2},
  pages     = {59--78},
  year      = {2001},
  url       = {https://doi.org/10.1016/S1571-0661(04)80920-4},
  doi       = {10.1016/S1571-0661(04)80920-4},
  timestamp = {Fri, 12 Feb 2021 22:17:06 +0100},
  biburl    = {https://dblp.org/rec/journals/entcs/HedinM01.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}



@article{ENGELFRIET1982283,
title = {Simple multi-visit attribute grammars},
journal = {Journal of Computer and System Sciences},
volume = {24},
number = {3},
pages = {283-314},
year = {1982},
issn = {0022-0000},
doi = {https://doi.org/10.1016/0022-0000(82)90030-7},
url = {https://www.sciencedirect.com/science/article/pii/0022000082900307},
author = {Joost Engelfriet and Gilberto Filé},
abstract = {An attribute grammar is simple multi-visit if each attribute of a nonterminal has a fixed visit-number associated with it such that, during attribute evaluation, the attributes of a node which have visit-number j are computed at the jth visit to the node. An attribute grammar is l-ordered if for each nonterminal a linear order of its attributes exists such that the attributes of a node can always be evaluated in that order (cf. the work of Kastens). An attribute grammar is simple multi-visit if and only if it is l-ordered. Every noncircular attribute grammar can be transformed into an equivalent simple multi-visit attribute grammar which uses the same semantic operations. For a given distribution of visit-numbers over the attributes, it can be decided in polynomial time whether the attributes can be evaluated according to these visit-numbers. The problem whether an attribute grammar is simple multi-visit is NP-complete.}
}
