@inproceedings{riouak2021precise,
  title={A Precise Framework for Source-Level Control-Flow Analysis},
  author={Riouak, Idriss and Reichenbach, Christoph and Hedin, G{\"o}rel and Fors, Niklas},
  booktitle={21st IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM},
  year={2021}
}

@article{Boyland_1995, journal={Remote Attribution}, author={Boyland, John Tang}, year={1995}, month={Sep}} 

@article{10.1016/j.scico.2005.06.005,
author = {Magnusson, Eva and Hedin, G\"{o}rel},
title = {Circular Reference Attributed Grammars — Their Evaluation and Applications},
year = {2007},
issue_date = {August, 2007},
publisher = {Elsevier North-Holland, Inc.},
address = {USA},
volume = {68},
number = {1},
issn = {0167-6423},
url = {https://doi.org/10.1016/j.scico.2005.06.005},
doi = {10.1016/j.scico.2005.06.005},
abstract = {This paper presents a combination of Reference Attributed Grammars (RAGs) and Circular Attribute Grammars (CAGs). While RAGs allow the direct and easy specification of nonlocally dependent information, CAGs allow iterative fixed-point computations to be expressed directly using recursive (circular) equations. We demonstrate how the combined formalism, Circular Reference Attributed Grammars (CRAGs), can take advantage of both these strengths, making it possible to express solutions to many problems in an easy way. We exemplify with the specification and computation of the nullable, first, and follow sets used in parser construction, a problem which is highly recursive and normally programmed by hand using an iterative algorithm. We also present a general demand-driven evaluation algorithm for CRAGs and some optimizations of it. The approach has been implemented and experimental results include computations on a series of grammars including that of Java 1.2. We also revisit some of the classical examples of CAGs and show how their solutions are facilitated by CRAGs.},
journal = {Sci. Comput. Program.},
month = aug,
pages = {21–37},
numpages = {17},
keywords = {Grammar flow, Fixed-point evaluation, Demand-driven evaluation, Reference attributes, Live analysis, Circular attribute evaluation, Attribute grammars}
}

@inproceedings{schone2020connecting,
  title={Connecting conceptual models using relational reference attribute grammars},
  author={Sch{\"o}ne, Ren{\'e} and Mey, Johannes and Ebert, Sebastian and A{\ss}mann, Uwe},
  booktitle={Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings},
  pages={1--11},
  year={2020}
}

@article{habibisharif,
  title={Sharif-TaaWS: A tool to generate Test as a Web Service (TaaWS) Through a Method-Based Attribute Grammar},
  author={Habibi, Elahe and Mirian-Hosseinabadi, Seyed-Hasan}
}

@INPROCEEDINGS{Knuth68semanticsof,
    author = {Donald E. Knuth},
    title = {Semantics of Context-Free Languages},
    booktitle = {In Mathematical Systems Theory},
    year = {1968},
    pages = {127--145}
}

@inproceedings{10.1007/978-3-642-25324-9_25,
author = {Hafiz, Rahmatullah and Frost, Richard A.},
title = {Modular Natural Language Processing Using Declarative Attribute Grammars},
year = {2011},
isbn = {9783642253232},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-25324-9_25},
doi = {10.1007/978-3-642-25324-9_25},
abstract = {A system based on a general top-down parsing algorithm has been developed which allows
language processors to be created as executable specifications of arbitrary attribute
grammars. Declarative notation of attribute grammars allows modular construction of
executable language definitions. Syntax is defined through general context-free grammar
rules, and meaning is defined by associated semantic rules with arbitrary dependencies.
An innovative technique allows parses to be pruned by arbitrary semantic constraints.
This new technique is useful in modelling natural-language phenomena by imposing unification-like
restrictions, and accommodating long-distance and cross-serial dependencies, which
cannot be handled by context-free rules alone.},
booktitle = {Proceedings of the 10th Mexican International Conference on Advances in Artificial Intelligence - Volume Part I},
pages = {291–304},
numpages = {14},
keywords = {lazy evaluation, top-down parsing, attribute grammars, compositional semantics, constraint-based formalism},
location = {Puebla, Mexico},
series = {MICAI'11}
}

@MISC{Boyland05remoteattribute,
    author = {John Tang Boyland},
    title = {Remote Attribute Grammars},
    year = {2005}
}

@article{10.1007/BF00288644,
author = {Kastens, Uwe},
title = {Ordered Attributed Grammars},
year = {1980},
issue_date = {March     1980},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {13},
number = {3},
issn = {0001-5903},
url = {https://doi.org/10.1007/BF00288644},
doi = {10.1007/BF00288644},
abstract = {Ordered attributed grammars are defined as a large subclass of semantically well-defined attributed grammars proposed by Knuth. An attributed grammar is ordered if for each symbol a partial order over the associated attributes can be given, such that in any context of the symbol the attributes are evaluable in an order which includes that partial order. The definition does not refer to a predefined strategy for attribute evaluation, e.g. several passes from left to right. For each attributed grammar evaluable by any predefined evaluation strategy such an order exists. The ordering property can be checked by an algorithm, which depends polynomially in time on the size of the input grammar. "Visit-sequences" are computed from the attribute dependencies given by an ordered attributed grammar. They describe the control flow of an algorithm for attribute evaluation which can be part of an automatically generated compiler.},
journal = {Acta Inf.},
month = mar,
pages = {229–256},
numpages = {28}
}

@inproceedings{Boyland1998AnalyzingDN,
  title={Analyzing Direct Non-local Dependencies in Attribute Grammars},
  author={J. Boyland},
  booktitle={CC},
  year={1998}
}

@book{10.5555/924544,
  title={Descriptional composition of compiler components},
  author={Boyland, John Tang},
  year={1996},
  publisher={University of California, Berkeley}
}

@article{10.1145/225540.225544,
author = {Boyland, John Tang},
title = {Conditional Attribute Grammars},
year = {1996},
issue_date = {Jan. 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {1},
issn = {0164-0925},
url = {https://doi.org/10.1145/225540.225544},
doi = {10.1145/225540.225544},
abstract = {Attribute grammars are a useful formalism for the specification of computations on structured terms. The classical definition of attribute grammars, however, has no way of treating conditionals nonstrictly. Consequently, the natural way of expressing many otherwise well-behaved computations involves a circularity. This article presents conditional attribute grammars, and extension of attribute grammars that enables more precise analysis of conditionals. In conditional attribute grammars, attribute equations may have guards. Equations are active only when their guards are satisfied. The standard attribute grammar evaluation classes are definable for conditional attribute grammars, and the corresponding evaluation techniques can be easily adapted. However, determining membership in standard evaluation classes such as 1-SWEEP, OAG, and SNC is NP-hard.},
journal = {ACM Trans. Program. Lang. Syst.},
month = jan,
pages = {73–108},
numpages = {36},
keywords = {attribute grammars, static analysis, language processor generators, demand evaluation, nonstrict evaluation, functional dependencies, conditionals}
}

@article{10.1145/13310.13320,
author = {Farrow, Rodney},
title = {Automatic Generation of Fixed-Point-Finding Evaluators for Circular, but Well-Defined, Attribute Grammars},
year = {1986},
issue_date = {July 1986},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/13310.13320},
doi = {10.1145/13310.13320},
abstract = {In the traditional formulation of attribute grammars (AGs) circularities are not allowed, that is, no attribute-instance in any derivation tree may be defined in terms of itself. Elsewhere in mathematics and computing, though, circular (or recursive) definitions are commonplace, and even essential. Given appropriate constraints, recursive definitions are well-founded, and the least fixed-points they denote are computable. This is also the case for circular AGs.This paper presents constraints on individual attributes and semantic functions of an AG that are sufficient to guarantee that a circular AG specifies a well-defined translation and that circularly-defined attribute-instances can be computed via successive approximation. AGs that satisfy these constraints are called finitely recursive.An attribute evaluation paradigm is presented that incorporates successive approximation to evaluate circular attribute-instances, along with an algorithm to automatically construct such an evaluator. The attribute evaluators so produced are static in the sense that the order of evaluation at each production-instance in the derivation-tree is determined at the time that each translator is generated.A final algorithm is presented that tells which individual attributes and functions must satisfy the constraints.},
journal = {SIGPLAN Not.},
month = jul,
pages = {85–98},
numpages = {14}
}

@article{DBLP:journals/informaticaSI/Hedin00,
  author    = {G{\"{o}}rel Hedin},
  title     = {Reference Attributed Grammars},
  journal   = {Informatica (Slovenia)},
  volume    = {24},
  number    = {3},
  year      = {2000},
  timestamp = {Mon, 15 Feb 2016 15:01:43 +0100},
  biburl    = {https://dblp.org/rec/journals/informaticaSI/Hedin00.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}




@article{DBLP:journals/entcs/HedinM01,
  author    = {G{\"{o}}rel Hedin and
               Eva Magnusson},
  title     = {JastAdd - a Java-based system for implementing front ends},
  journal   = {Electron. Notes Theor. Comput. Sci.},
  volume    = {44},
  number    = {2},
  pages     = {59--78},
  year      = {2001},
  url       = {https://doi.org/10.1016/S1571-0661(04)80920-4},
  doi       = {10.1016/S1571-0661(04)80920-4},
  timestamp = {Fri, 12 Feb 2021 22:17:06 +0100},
  biburl    = {https://dblp.org/rec/journals/entcs/HedinM01.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{4236994589494506a212280893694207,
title = "Reference Attributed Grammars",
abstract = "An object-oriented extension to canonical attribute grammars is described, permitting attributes to be references to arbitrary nodes in the syntax tree, and attributes to be accessed via the reference attributes. Important practical problems such as name and type analysis for object-oriented languages can be expressed in a concise and modular manner in these grammars, and an optimal evaluation algorithm is available. An extensive example is given, capturing all the key constructs in object-oriented languages including block structure, classes, inheritance, qualified use, and assignment compatibility in the presence of subtyping. The formalism and algorithm have been implemented in APPLAB, an interactive language development tool.",
author = "G{\"o}rel Hedin",
year = "2000",
language = "English",
volume = "24",
pages = "301--317",
journal = "Informatica",
issn = "0868-4952",
publisher = "Slovenian Society Informatika",
number = "3",
}

@article{ENGELFRIET1982283,
title = {Simple multi-visit attribute grammars},
journal = {Journal of Computer and System Sciences},
volume = {24},
number = {3},
pages = {283-314},
year = {1982},
issn = {0022-0000},
doi = {https://doi.org/10.1016/0022-0000(82)90030-7},
url = {https://www.sciencedirect.com/science/article/pii/0022000082900307},
author = {Joost Engelfriet and Gilberto Filé},
abstract = {An attribute grammar is simple multi-visit if each attribute of a nonterminal has a fixed visit-number associated with it such that, during attribute evaluation, the attributes of a node which have visit-number j are computed at the jth visit to the node. An attribute grammar is l-ordered if for each nonterminal a linear order of its attributes exists such that the attributes of a node can always be evaluated in that order (cf. the work of Kastens). An attribute grammar is simple multi-visit if and only if it is l-ordered. Every noncircular attribute grammar can be transformed into an equivalent simple multi-visit attribute grammar which uses the same semantic operations. For a given distribution of visit-numbers over the attributes, it can be decided in polynomial time whether the attributes can be evaluated according to these visit-numbers. The problem whether an attribute grammar is simple multi-visit is NP-complete.}
}
